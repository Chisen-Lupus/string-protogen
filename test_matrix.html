<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Protogen Half-Face Expression Matrix</title>
    <link rel="stylesheet" href="errorLogger.css" />
    <style>
      body {
        margin: 0;
        background-color: black;
        overflow: hidden;
        display: flex;
        justify-content: center;
        align-items: center;
        flex-direction: column;
        height: 100vh;
      }
      canvas {
        position: relative;
        width: 100vw;
        height: 62.5vw;
        border: 1px solid gray;
      }
    </style>
  </head>
  <body>
    <canvas id="matrixCanvas" width="1920" height="1200"></canvas>
    <div id="errorLog">No errors yet.</div>
    <script type="module">
      import { setupErrorLogger } from "./errorLogger.js";
      setupErrorLogger();

      const canvas = document.getElementById("matrixCanvas");
      const ctx = canvas.getContext("2d");
      const cellSize = 60;
      const circleRadius = 20;
      const matrixSize = 8;

      // Define matrix data
      const A1 = [
        [0x00, 0xff, 0xff, 0xfe, 0xfe, 0xfc, 0xf8, 0xf0],
        [0x00, 0x00, 0x07, 0x1f, 0x3f, 0x7f, 0x7f, 0x1f],
        [0x00, 0x00, 0x00, 0x00, 0x70, 0xc0, 0x80, 0x00],
        [0x00, 0x00, 0x00, 0x00, 0x0e, 0x03, 0x01, 0x00],
        [0x00, 0x00, 0xe0, 0xf8, 0xfc, 0xfe, 0xfe, 0xf8],
        [0x00, 0xff, 0xff, 0x7f, 0x7f, 0x3f, 0x1f, 0x0f],
      ];
      const B1 = [
        [0x00, 0x00, 0xc0, 0xc0, 0x80, 0x00, 0x00, 0x00],
        [0x00, 0x00, 0x03, 0x07, 0x1f, 0x70, 0xc0, 0x00],
        [0x00, 0x00, 0x40, 0xe0, 0xb0, 0x18, 0x0d, 0x07],
        [0x00, 0x00, 0x00, 0x00, 0x21, 0x77, 0xdc, 0x08],
        [0x00, 0x00, 0x00, 0x00, 0x84, 0xee, 0x3b, 0x10],
        [0x00, 0x00, 0x02, 0x07, 0x0d, 0x18, 0xb0, 0xe0],
        [0x00, 0x00, 0xc0, 0xe0, 0xf8, 0x0e, 0x03, 0x00],
        [0x00, 0x00, 0x03, 0x03, 0x01, 0x00, 0x00, 0x00],
      ];

      const A2 = [
        [0xc0, 0x20, 0x90, 0x50, 0x50, 0x40, 0x80, 0x00],
        [0x07, 0x08, 0x13, 0x14, 0x13, 0x08, 0x07, 0x00],
        [0x00, 0x00, 0x00, 0x00, 0x70, 0xc0, 0x80, 0x00],
        [0x00, 0x00, 0x00, 0x00, 0x0e, 0x03, 0x01, 0x00],
        [0xe0, 0x10, 0xc8, 0x28, 0xc8, 0x10, 0xe0, 0x00],
        [0x03, 0x04, 0x09, 0x0a, 0x0a, 0x02, 0x01, 0x00],
      ];
      const B2 = [
        [0x00, 0x00, 0x00, 0x00, 0x80, 0xe0, 0xe0, 0x00],
        [0x00, 0x00, 0x70, 0xdc, 0x07, 0x03, 0x01, 0x00],
        [0x00, 0x00, 0x00, 0x01, 0xcf, 0x78, 0x00, 0x00],
        [0x00, 0x00, 0x00, 0x07, 0x0d, 0x38, 0x60, 0x00],
        [0x00, 0x00, 0x00, 0xe0, 0xb0, 0x1c, 0x06, 0x00],
        [0x00, 0x00, 0x00, 0x80, 0xf3, 0x1e, 0x00, 0x00],
        [0x00, 0x00, 0x0e, 0x3b, 0xe0, 0xc0, 0x80, 0x00],
        [0x00, 0x00, 0x00, 0x00, 0x01, 0x07, 0x07, 0x00],
      ];
      
      function interpolate(a, b, t) {
        return a * (1 - t) + b * t;
      }

      function drawMatrix(progress, mat_before, mat_after, offsetX, offsetY) {
        for (let i = 0; i < matrixSize; i++) {
          for (let j = 0; j < matrixSize; j++) {
            const phase_before = (mat_before[i] & (1 << (7 - j))) !== 0;
            const phase_after = (mat_after[i] & (1 << (7 - j))) !== 0;
            const x = offsetX + j * cellSize;
            const y = offsetY + i * cellSize;
            // Interpolate phase to determine the height of the ellipse
            const phase_now = interpolate(phase_before, phase_after, progress);
            // Calculate ellipse height based on the phase
            const ellipseHeight = circleRadius * 2 * phase_now; // Height varies between 0 and full diameter
            ctx.beginPath();
            ctx.ellipse(x, y, circleRadius, ellipseHeight / 2, 0, 0, Math.PI * 2); // Dynamic height
            ctx.fillStyle = `rgba(255, 0, 0, 1)`; // Keep color opaque
            ctx.fill();

          }
        }
      }

      function drawAll(progress, currentA, currentB, nextA, nextB) {
        // upper matrices
        drawMatrix(progress, currentA[0], nextA[0], 900 + 480, 50);
        drawMatrix(progress, currentA[1], nextA[1], 900, 50);
        // Lower matrices
        drawMatrix(progress, currentB[0], nextB[0], 100 + 3 * 480, 700);
        drawMatrix(progress, currentB[1], nextB[1], 100 + 2 * 480, 700);
        drawMatrix(progress, currentB[2], nextB[2], 100 + 480, 700);
        drawMatrix(progress, currentB[3], nextB[3], 100, 700);
      }

      let toggle = true; // indicating which is the next matrix
      let frame = 0; // grame counter
      let progress = 0; // Animation progress (0 to 1)
      let ppf = 0.05; // progress per frame

      function animate() {
        // Animate the toggle
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const currentA = toggle ? A1 : A2;
        const currentB = toggle ? B1 : B2;
        const nextA = toggle ? A2 : A1;
        const nextB = toggle ? B2 : B1;
        drawAll(progress, currentA, currentB, nextA, nextB);
        // set progress
        if (frame>=180) { // 180 frames is 3s
          frame = 0;
          toggle = !toggle;
        }
        progress = Math.min(frame*ppf, 1);
        frame += 1;
        requestAnimationFrame(animate);
      }

      animate();
    </script>
  </body>
</html>
